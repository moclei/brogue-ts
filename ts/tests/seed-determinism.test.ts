/*
 *  seed-determinism.test.ts — Phase 4a: Seed Determinism Tests
 *  brogue-ts
 *
 *  These tests capture and lock in the deterministic output of the RNG
 *  and dungeon generation pipeline. If any future change breaks determinism,
 *  these tests will fail.
 *
 *  The reference values were generated by the TS implementation and verified
 *  against the C code's algorithm. Once hardcoded, they serve as regression
 *  guards.
 */

import { describe, it, expect, beforeEach } from "vitest";
import {
    seedRandomGenerator,
    randRange,
    rand64bits,
    setRNG,
    resetRandomNumbersGenerated,
    getRandomNumbersGenerated,
} from "../src/math/rng.js";
import { RNG } from "../src/types/enums.js";
import {
    allocGrid,
    fillGrid,
} from "../src/grid/grid.js";
import { DCOLS, DROWS } from "../src/types/constants.js";
import { carveDungeon } from "../src/architect/architect.js";
import { dungeonProfileCatalog } from "../src/globals/dungeon-profile-catalog.js";
import referenceValues from "./fixtures/reference_values.json" with { type: "json" };

// =============================================================================
// Helpers
// =============================================================================

/** Simple FNV-1a-style hash of an integer grid for regression comparison. */
function hashGrid(grid: number[][]): number {
    let hash = 2166136261;
    for (let i = 0; i < DCOLS; i++) {
        for (let j = 0; j < DROWS; j++) {
            hash ^= grid[i][j];
            hash = Math.imul(hash, 16777619) >>> 0;
        }
    }
    return hash;
}

/**
 * Generate N random numbers with randRange(lo, hi) after seeding.
 * Returns the array of values.
 */
function generateSequence(seed: bigint, n: number, lo: number, hi: number): number[] {
    seedRandomGenerator(seed);
    setRNG(RNG.Substantive);
    const vals: number[] = [];
    for (let i = 0; i < n; i++) {
        vals.push(randRange(lo, hi));
    }
    return vals;
}

// =============================================================================
// Step 1: RNG Raw Output Regression
// =============================================================================

describe("RNG raw output regression", () => {
    beforeEach(() => {
        setRNG(RNG.Substantive);
    });

    it("seed 12345: first 20 randRange(0,999) values are deterministic", () => {
        const vals = generateSequence(12345n, 20, 0, 999);
        // Lock in the reference values — these MUST NOT change
        expect(vals).toMatchInlineSnapshot(`
          [
            148,
            83,
            296,
            676,
            119,
            711,
            662,
            584,
            803,
            320,
            852,
            120,
            528,
            495,
            927,
            213,
            412,
            841,
            395,
            20,
          ]
        `);
    });

    it("seed 42: first 20 randRange(0,999) values are deterministic", () => {
        const vals = generateSequence(42n, 20, 0, 999);
        expect(vals).toMatchInlineSnapshot(`
          [
            286,
            949,
            468,
            131,
            377,
            211,
            72,
            590,
            564,
            327,
            567,
            117,
            421,
            887,
            142,
            844,
            541,
            672,
            38,
            121,
          ]
        `);
    });

    it("seed 1: first 20 randRange(0,999) values are deterministic", () => {
        const vals = generateSequence(1n, 20, 0, 999);
        expect(vals).toMatchInlineSnapshot(`
          [
            634,
            121,
            199,
            819,
            298,
            712,
            605,
            590,
            866,
            93,
            659,
            760,
            940,
            251,
            257,
            320,
            265,
            165,
            333,
            55,
          ]
        `);
    });

    it("seed 12345: rand64bits produces deterministic value", () => {
        seedRandomGenerator(12345n);
        setRNG(RNG.Substantive);
        const val = rand64bits();
        expect(val.toString()).toMatchInlineSnapshot(`"2745062162151181819"`);
    });

    it("seed 1: level seeds match (backward-compatible path)", () => {
        // Mirrors initializeRogue's level seed generation for seed < 2^32
        seedRandomGenerator(1n);
        setRNG(RNG.Substantive);
        const levelSeeds: string[] = [];
        for (let i = 0; i < 10; i++) {
            const lo = BigInt(randRange(0, 9999));
            const hi = BigInt(randRange(0, 9999));
            levelSeeds.push((lo + 10000n * hi).toString());
        }
        expect(levelSeeds).toMatchInlineSnapshot(`
          [
            "12106340",
            "81901998",
            "71242980",
            "59066056",
            "9328667",
            "76076594",
            "25119405",
            "32072575",
            "16532653",
            "5543339",
          ]
        `);
    });

    it("same seed always produces same 10,000-call sequence", () => {
        const run1 = generateSequence(99999n, 10000, 0, 2147483647);
        const run2 = generateSequence(99999n, 10000, 0, 2147483647);
        expect(run1).toEqual(run2);
    });

    it("different seeds produce different sequences", () => {
        const a = generateSequence(1n, 100, 0, 999);
        const b = generateSequence(2n, 100, 0, 999);
        // At least some values should differ
        const diffs = a.filter((v, i) => v !== b[i]).length;
        expect(diffs).toBeGreaterThan(50);
    });

    it("RNG counter tracks correctly over 1000 calls", () => {
        seedRandomGenerator(42n);
        setRNG(RNG.Substantive);
        resetRandomNumbersGenerated();
        for (let i = 0; i < 1000; i++) {
            randRange(0, 99);
        }
        expect(getRandomNumbersGenerated()).toBe(1000);
    });
});

// =============================================================================
// Step 2: carveDungeon Grid Hash Regression
// =============================================================================

describe("carveDungeon grid hash regression", () => {
    /**
     * For each seed/depth combo, generate a dungeon and capture the grid hash.
     * The hash is a deterministic function of the grid contents.
     * If the dungeon generation algorithm changes, the hash will change.
     */
    const testCases: Array<{ seed: bigint; depth: number; label: string }> = [
        { seed: 1n,     depth: 1, label: "seed 1, depth 1" },
        { seed: 1n,     depth: 5, label: "seed 1, depth 5" },
        { seed: 12345n, depth: 1, label: "seed 12345, depth 1" },
        { seed: 12345n, depth: 5, label: "seed 12345, depth 5" },
        { seed: 12345n, depth: 10, label: "seed 12345, depth 10" },
        { seed: 42n,    depth: 1, label: "seed 42, depth 1" },
        { seed: 42n,    depth: 3, label: "seed 42, depth 3" },
        { seed: 99999n, depth: 1, label: "seed 99999, depth 1" },
        { seed: 99999n, depth: 7, label: "seed 99999, depth 7" },
        { seed: 55555n, depth: 13, label: "seed 55555, depth 13" },
    ];

    for (const tc of testCases) {
        it(`${tc.label}: grid hash is self-consistent`, () => {
            // Run 1
            seedRandomGenerator(tc.seed);
            const grid1 = allocGrid();
            fillGrid(grid1, 0);
            carveDungeon(grid1, tc.depth, 26, dungeonProfileCatalog);
            const hash1 = hashGrid(grid1);

            // Run 2 with same seed
            seedRandomGenerator(tc.seed);
            const grid2 = allocGrid();
            fillGrid(grid2, 0);
            carveDungeon(grid2, tc.depth, 26, dungeonProfileCatalog);
            const hash2 = hashGrid(grid2);

            expect(hash1).toBe(hash2);
            expect(hash1).not.toBe(0); // dungeon has content
        });
    }

    // Lock in specific hash values as regression guards
    it("locked-in grid hashes for key seed/depth combos", () => {
        const hashes: Record<string, number> = {};

        for (const tc of testCases) {
            seedRandomGenerator(tc.seed);
            const grid = allocGrid();
            fillGrid(grid, 0);
            carveDungeon(grid, tc.depth, 26, dungeonProfileCatalog);
            hashes[tc.label] = hashGrid(grid);
        }

        expect(hashes).toMatchInlineSnapshot(`
          {
            "seed 1, depth 1": 384024991,
            "seed 1, depth 5": 2007232852,
            "seed 12345, depth 1": 1958435306,
            "seed 12345, depth 10": 169133054,
            "seed 12345, depth 5": 201195335,
            "seed 42, depth 1": 3665376495,
            "seed 42, depth 3": 1131347664,
            "seed 55555, depth 13": 4207562459,
            "seed 99999, depth 1": 2270523418,
            "seed 99999, depth 7": 2902999023,
          }
        `);
    });
});

// =============================================================================
// Step 3: Level Seed Generation Regression
// =============================================================================

describe("level seed generation regression", () => {
    it("seed 1: level seeds for depths 1-26 are deterministic", () => {
        seedRandomGenerator(1n);
        setRNG(RNG.Substantive);

        const levelSeeds: string[] = [];
        for (let depth = 0; depth <= 26; depth++) {
            // Backward-compatible seed generation (seed < 2^32)
            const lo = BigInt(randRange(0, 9999));
            const hi = BigInt(randRange(0, 9999));
            const levelSeed = lo + 10000n * hi;
            levelSeeds.push(levelSeed === 0n ? String(depth + 1) : levelSeed.toString());
        }

        expect(levelSeeds).toMatchInlineSnapshot(`
          [
            "12106340",
            "81901998",
            "71242980",
            "59066056",
            "9328667",
            "76076594",
            "25119405",
            "32072575",
            "16532653",
            "5543339",
            "95523606",
            "30646330",
            "97929997",
            "1617946",
            "78000365",
            "35250479",
            "75349227",
            "17230347",
            "33014530",
            "52769001",
            "43537766",
            "3840514",
            "42727340",
            "30604686",
            "44344034",
            "93552893",
            "54944530",
          ]
        `);
    });

    it("seed 12345: level seeds for depths 1-26 are deterministic", () => {
        seedRandomGenerator(12345n);
        setRNG(RNG.Substantive);

        const levelSeeds: string[] = [];
        for (let depth = 0; depth <= 26; depth++) {
            const lo = BigInt(randRange(0, 9999));
            const hi = BigInt(randRange(0, 9999));
            const levelSeed = lo + 10000n * hi;
            levelSeeds.push(levelSeed === 0n ? String(depth + 1) : levelSeed.toString());
        }

        expect(levelSeeds).toMatchInlineSnapshot(`
          [
            "8351488",
            "67652961",
            "71121196",
            "58406624",
            "32018036",
            "12018527",
            "49525289",
            "21379275",
            "84194122",
            "2003959",
            "59358848",
            "62016043",
            "55534663",
            "99168401",
            "98204258",
            "24880248",
            "2086223",
            "27754584",
            "79522362",
            "38578100",
            "77847594",
            "42029283",
            "14853774",
            "13313602",
            "75139990",
            "67573522",
            "28940122",
          ]
        `);
    });
});

// =============================================================================
// Step 4: Cross-Validation Against C Reference Values
// =============================================================================

describe("cross-validation against C reference values", () => {
    /**
     * These tests compare TS RNG output directly against values generated
     * by compiling and running the original C code (generate_reference.c).
     * This is the strongest correctness test: it proves the TS port produces
     * bit-identical RNG output to the C implementation.
     */

    beforeEach(() => {
        setRNG(RNG.Substantive);
    });

    it("seed 12345 randRange(0,999) matches C output exactly", () => {
        const vals = generateSequence(12345n, 20, 0, 999);
        expect(vals).toEqual(referenceValues.rng.seed_12345_range_0_999);
    });

    it("seed 42 randRange(0,999) matches C output exactly", () => {
        const vals = generateSequence(42n, 20, 0, 999);
        expect(vals).toEqual(referenceValues.rng.seed_42_range_0_999);
    });

    it("seed 1 randRange(0,99) matches C output exactly", () => {
        const vals = generateSequence(1n, 20, 0, 99);
        expect(vals).toEqual(referenceValues.rng.seed_1_range_0_99);
    });

    it("seed 1 randRange(0,999) matches C output exactly", () => {
        const vals = generateSequence(1n, 20, 0, 999);
        expect(vals).toEqual(referenceValues.rng.seed_1_range_0_999);
    });

    it("seed 1 level seeds match C output exactly", () => {
        seedRandomGenerator(1n);
        setRNG(RNG.Substantive);
        const levelSeeds: number[] = [];
        for (let i = 0; i < 10; i++) {
            const lo = randRange(0, 9999);
            const hi = randRange(0, 9999);
            levelSeeds.push(lo + hi * 10000);
        }
        expect(levelSeeds).toEqual(referenceValues.rng.seed_1_level_seeds);
    });
});
