/*
 *  cross-validation.test.ts — Validate TS port against C reference values
 *  brogue-ts
 *
 *  Reference values were generated by compiling and running the C source
 *  (tests/fixtures/generate_reference.c). If these tests fail, the TS
 *  port has diverged from the C implementation.
 */

import { describe, it, expect, beforeEach } from "vitest";
import {
    seedRandomGenerator,
    randRange,
    setRNG,
} from "../src/math/rng.js";
import {
    fpSqrt,
    fpPow,
    fpFromInt,
} from "../src/math/fixpt.js";
import { RNG } from "../src/types/enums.js";
import referenceData from "./fixtures/reference_values.json" with { type: "json" };

// ===== RNG Cross-Validation =====

describe("RNG cross-validation against C", () => {
    it("seed 12345, rand_range(0, 999) — first 20 values", () => {
        seedRandomGenerator(12345n);
        setRNG(RNG.Substantive);

        const expected = referenceData.rng.seed_12345_range_0_999;
        const actual = Array.from({ length: 20 }, () => randRange(0, 999));

        expect(actual).toEqual(expected);
    });

    it("seed 42, rand_range(0, 999) — first 20 values", () => {
        seedRandomGenerator(42n);
        setRNG(RNG.Substantive);

        const expected = referenceData.rng.seed_42_range_0_999;
        const actual = Array.from({ length: 20 }, () => randRange(0, 999));

        expect(actual).toEqual(expected);
    });

    it("seed 1, rand_range(0, 99) — first 20 values", () => {
        seedRandomGenerator(1n);
        setRNG(RNG.Substantive);

        const expected = referenceData.rng.seed_1_range_0_99;
        const actual = Array.from({ length: 20 }, () => randRange(0, 99));

        expect(actual).toEqual(expected);
    });
});

// ===== Fixed-Point Cross-Validation =====

describe("fpSqrt cross-validation against C", () => {
    it("matches C for all lookup-table values (0..127)", () => {
        const sqrtRef = referenceData.fixpt.sqrt as Record<string, number>;
        for (let i = 0; i <= 127; i++) {
            const expected = BigInt(sqrtRef[String(i)]);
            const actual = fpSqrt(fpFromInt(i));
            expect(actual).toBe(expected);
        }
    });
});

describe("fpPow cross-validation against C", () => {
    it("2^e matches C for e = -5..10", () => {
        const powRef = referenceData.fixpt.pow_2 as Record<string, number>;
        const base = fpFromInt(2);
        for (let e = -5; e <= 10; e++) {
            const expected = BigInt(powRef[String(e)]);
            const actual = fpPow(base, e);
            expect(actual).toBe(expected);
        }
    });

    it("3^e matches C for e = -3..5", () => {
        const powRef = referenceData.fixpt.pow_3 as Record<string, number>;
        const base = fpFromInt(3);
        for (let e = -3; e <= 5; e++) {
            const expected = BigInt(powRef[String(e)]);
            const actual = fpPow(base, e);
            expect(actual).toBe(expected);
        }
    });
});
